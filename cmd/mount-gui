#!/bin/sh
export INFO='mount or unmount a drive with Rofi dialog and udisksctl'

~/scripts/cmd/require udisksctl || exit 1

lock_file="$HOME/.cache/mount-gui.lock"
log_file="$HOME/.cache/mount-gui.log"

# Report final message (error or success)
# - Print to stdout
# - Log to file
# - Send desktop notification (with `--notify`)
notify_arg="$1"
finally() {
    msg="$1"
    echo "$msg"
    echo "$msg" >> "$log_file"
    if [ "$notify_arg" = '--notify' ]; then
        notify-send "$msg" -t 2000
    fi
}

# Grep for value, by key name, in `udisksctl info` output
info_value() {
    info="$1"
    name="$2"
    [ -n "$info" ] || exit 1
    [ -n "$name" ] || exit 1
    row="$(echo "$info" | grep "$name:")"
    [ -n "$row" ]  || exit 1
    echo "$row" | awk '{print $2}'
}

# Wait for lockfile to be removed
# Give up after a certain time
if [ -e "$lock_file" ]; then
    echo 'mount-gui: waiting for lockfile...'
    interval=0.1
    max_attempts=40 # 4 seconds
    attempts=0
    while [ -e "$lock_file" ]; do
        if [ "$attempts" -gt "$max_attempts" ]; then
            msg="mount-gui: waited too long for process lock. try removing $lock_file if this error persists."
            finally "$msg"
            exit 1
        fi
        sleep "$interval"
        attempts=$((attempts + 1))
    done
    echo 'mount-gui: okay.'
fi
touch "$lock_file"

# Find all mountable drives
# NOTE: This only searchs for `sdXX` devices!
available=''
for drive in /dev/sd[a-z][0-9]; do
    # Get device information
    info="$(udisksctl info -b "$drive")"
    type="$( info_value "$info" 'IdType'  || exit 1)"
    label="$(info_value "$info" 'IdLabel' || exit 1)"
    mount="$(info_value "$info" 'MountPoints')"
    # Required to mount/unmount
    [ -n "$type" ] || continue

    # Format string with markdown, to display device entry
    [ -n "$mount" ] \
        && action="<span foreground='red'  >Unmount</span>" \
        || action="<span foreground='green'>  Mount</span>"
    entry="$(printf '<b>%s  %-12s</b> %-12s <i>%-5s</i>   <b>%-s</b>' \
        "$action" "$label" "$drive" "$type" "$mount")"

    # Add to list, separated by newline
    [ -n "$available" ] && available="$available
"
    available="$available$entry"
done

# Read input with Rofi
prompt='Mount or unmount a drive:'
answer="$(echo "$available" | rofi -dmenu -i -markup-rows -p "$prompt")"
# Cancelled
if [ -z "$answer" ]; then
    rm "$lock_file"
    echo 'Cancelled'
    exit 0 
fi

# Extract device file path from answer
drive="$(echo "$answer" | grep -oP '/dev/[^ ]*')"
[ -n "$drive" ] || exit 1

# Mount or unmount, and lock other instances of this script
run_action() {
    action="$1"
    # Capture stdout and sterr
    msg="$(udisksctl "$action" -b "$drive" 2>&1)"
    code="$?"
    finally "$msg"
    rm "$lock_file"
    exit "$code"
}

# Unmount if already mounted, otherwise mount
# This is redundant, but the best way I could think of
info="$(udisksctl info -b "$drive")"
[ -n "$(info_value "$info" 'MountPoints')" ] \
    && action='unmount' \
    || action='mount'
run_action "$action"

